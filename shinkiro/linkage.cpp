#include "linkage.h"

#define SHOW_DEBUG_OUTPUT true

/**********************************************************Base functions (constructor etc)************************************************/

//Default Link constructor, primarily useful for testing so we fill with some arbitrary values.
shinkiro::Link::Link() : m_length(2), m_radius(1), m_mass(1), m_intertia(1), m_theta(EIGEN_PI/4), m_omega(1), m_alpha(1), m_forceX(0), m_forceY(0), m_torque(0) {
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Link::Link(): Link constructed succesfully.\n";
	}
}

//Default Linkage constructor, primarily useful for testing so we fill with some arbitrary values.  Defaults to 3 link linkage.
shinkiro::Linkage::Linkage() {
	//We default to a 3 link linkage with the default link characteristics generated by the default constructor of Link.
	shinkiro::Link temp;

	//Fill the Link vector.
	for (int i = 0; i < 3; ++i) {
		m_links.push_back(temp);
	}
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Linkage::Linkage(): Linkage constructed succesfully.\n";
	}
}

/**********************************************************Math helper functions***********************************************************/

//Return sin(theta), which commonly appears in calculations.
double shinkiro::Link::f_sin() const {
	return sin(m_theta);
}	

//Return cos(theta), which commonly appears in calculations.
double shinkiro::Link::f_cos() const {
	return cos(m_theta);
}

/**********************************************************Solver functions***************************************************************/

//Use inverse dynamics to calculate the forces and moments for a three link planar bipedal / inverted pendulum model.
//Assumes foot is massless and remains grounded for period of analysis.  Assumes that position, velocity, and acceleration values are known and defined in m_theta, m_omega, m_alpha.
//Returns a linkage with the m_forceX, m_forceY, and m_torque values of each link found.
shinkiro::Linkage shinkiro::Linkage::f_inverseDynamics() {
	//Handle the cases for the current number of links.  Eventually generically handle linkages, but for now prototype around 3 link model.
	if (m_links.size() != 3) {
		std::cout << "Invalid linkage length\n";
		return *this;
	}

	//The inverse dynamics for linkage of length three can be written in the form Af=B.
	//Prellocate A and B.
	Eigen::MatrixXd A = Eigen::MatrixXd::Zero(9,9);
	Eigen::MatrixXd B = Eigen::MatrixXd::Zero(9, 1);

	//Define the matrix A.
	A << 1, -1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, -1, 0, 0, 0, 0, 0,
		1, -1, m_links[0].m_radius* sin(m_links[0].m_theta), -1 * m_links[0].m_radius * cos(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* sin(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* cos(m_links[0].m_theta), 0, 0, 0,
		0, 1, 0, 0, 0, 0, -1, 0, 0,
		0, 0, 0, 1, 0, 0, 0, -1, 0,
		0, m_links[1].m_radius* sin(m_links[1].m_theta), 0, -1 * m_links[1].m_radius * cos(m_links[1].m_theta), 0, 1, (m_links[1].m_length - m_links[1].m_radius)* sin(m_links[1].m_theta), -1 * (m_links[1].m_length - m_links[1].m_radius) * cos(m_links[1].m_theta), -1,
		0, 0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 1, 0;

	std::cout << A;



	//temp
	return *this;
}