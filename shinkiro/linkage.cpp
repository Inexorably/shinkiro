#include "linkage.h"

#define SHOW_DEBUG_OUTPUT true

/**********************************************************Base functions (constructor etc)************************************************/

//Default Link constructor, primarily useful for testing so we fill with some arbitrary values.
shinkiro::Link::Link() : m_length(2), m_radius(1), m_mass(1), m_inertia(1), m_theta(EIGEN_PI/4), m_omega(1), m_alpha(1), m_forceX(1), m_forceY(-1), m_torque(1) {
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Link::Link(): Link constructed succesfully.\n";
	}
}

//Default Linkage constructor, primarily useful for testing so we fill with some arbitrary values.  Defaults to 3 link linkage.
shinkiro::Linkage::Linkage() {
	//We default to a 3 link linkage with the default link characteristics generated by the default constructor of Link.
	shinkiro::Link temp;

	//Fill the Link vector.
	for (int i = 0; i < 3; ++i) {
		m_links.push_back(temp);
	}
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Linkage::Linkage(): Linkage constructed succesfully.\n";
	}
}

/**********************************************************Math helper functions***********************************************************/

//Returns cos(theta)*alpha.
double shinkiro::Link::f_cta() const {
	return cos(m_theta) * m_alpha;
}

//Returns sin(theta)*alpha.
double shinkiro::Link::f_sta() const {
	return sin(m_theta) * m_alpha;
}

//Returns cos(theta)*omega^2.
double shinkiro::Link::f_ctw2() const {
	return cos(m_theta) * pow(m_omega, 2);
}

//Returns sin(theta)*omega^2.
double shinkiro::Link::f_stw2() const {
	return sin(m_theta) * pow(m_omega, 2);
}

/**********************************************************Solver functions***************************************************************/

//Use inverse dynamics to calculate the forces and moments for a three link planar bipedal / inverted pendulum model.
//Assumes foot is massless and remains grounded for period of analysis.  Assumes that position, velocity, and acceleration values are known and defined in m_theta, m_omega, m_alpha.
//Returns a vector of the forces and torques of order [Fx1; Fx2; Fy1; Fy2; T1; T2; Fx3; Fy3; T3].
Eigen::VectorXd shinkiro::Linkage::f_inverseDynamics() {
	//Handle the cases for the current number of links.  Eventually generically handle linkages, but for now prototype around 3 link model.
	if (m_links.size() != 3) {
		std::cout << "Invalid linkage length\n";
		return Eigen::VectorXd(8);
	}

	//The inverse dynamics for linkage of length three can be written in the form Af=b.
	//Prellocate A and b.
	Eigen::MatrixXd A(9, 9);
	Eigen::VectorXd b(9);

	//Define the matrix A, which is 9x9.
	A << 1, -1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, -1, 0, 0, 0, 0, 0,
		1, -1, m_links[0].m_radius* sin(m_links[0].m_theta), -1 * m_links[0].m_radius * cos(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* sin(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* cos(m_links[0].m_theta), 0, 0, 0,
		0, 1, 0, 0, 0, 0, -1, 0, 0,
		0, 0, 0, 1, 0, 0, 0, -1, 0,
		0, m_links[1].m_radius* sin(m_links[1].m_theta), 0, -1 * m_links[1].m_radius * cos(m_links[1].m_theta), 0, 1, (m_links[1].m_length - m_links[1].m_radius)* sin(m_links[1].m_theta), -1 * (m_links[1].m_length - m_links[1].m_radius) * cos(m_links[1].m_theta), -1,
		0, 0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 1, 0,
		0, 0, 0, 0, 0, 0, m_links[2].m_radius* sin(m_links[2].m_theta), -m_links[2].m_radius * cos(m_links[2].m_theta), 1;

	//Define the vector B, which is 9x1.
	b << -m_links[0].m_mass * m_links[0].m_radius * (m_links[0].f_sta() + m_links[0].f_ctw2()),
		m_links[0].m_mass* (m_links[0].m_radius * (m_links[0].f_cta() - m_links[0].f_stw2()) + shinkiro::g),
		m_links[0].m_inertia* m_links[0].m_alpha,
		-m_links[1].m_mass * (m_links[0].m_length * (m_links[0].f_sta() + m_links[0].f_ctw2()) + m_links[1].m_radius * (m_links[1].f_sta() + m_links[1].f_ctw2())),
		m_links[1].m_mass* (m_links[0].m_length * (m_links[0].f_cta() - m_links[0].f_stw2()) + m_links[1].m_radius * (m_links[1].f_cta() - m_links[1].f_stw2()) + shinkiro::g),
		m_links[1].m_inertia* m_links[1].m_alpha,
		-m_links[2].m_mass * (m_links[0].m_length * (m_links[0].f_sta() + m_links[0].f_ctw2()) + m_links[1].m_length * (m_links[1].f_sta() + m_links[1].f_ctw2()) + m_links[2].m_radius * (m_links[2].f_sta() + m_links[2].f_ctw2())),
		m_links[2].m_mass* (m_links[0].m_length * (m_links[0].f_cta() - m_links[0].f_stw2()) + m_links[1].m_length * (m_links[1].f_cta() - m_links[1].f_stw2()) + m_links[2].m_radius * (m_links[2].f_cta() - m_links[2].f_stw2()) + shinkiro::g),
		m_links[2].m_inertia* m_links[2].m_alpha;


	//Find f = b\A.
	return A.colPivHouseholderQr().solve(b);
}

//Use forward dynamics to find the angular accelerations resulting from some given forces and torques.
//Assumes foot is massless and remains grounded for period of analysis.
//Returns a vector of angular accelerations of order [alpha1; alpha2; alpha3].
Eigen::VectorXd shinkiro::Linkage::f_forwardDynamics() {
	//Handle the cases for the current number of links.  Eventually generically handle linkages, but for now prototype around 3 link model.
	if (m_links.size() != 3) {
		std::cout << "Invalid linkage length\n";
		return Eigen::VectorXd(3);
	}
	
	//Find the angular accelerations from the moment balance equations.
	//TODO: Adapt this function for Linkage with n links, as the moment equations are consistently the same.
	double alpha1 = (m_links[0].m_torque - m_links[1].m_torque + m_links[0].m_forceX * m_links[0].m_radius * sin(m_links[0].m_theta) - m_links[0].m_forceY * m_links[0].m_radius * cos(m_links[0].m_theta)
		+ m_links[1].m_forceX * (m_links[0].m_length - m_links[0].m_radius) * sin(m_links[0].m_theta) - m_links[1].m_forceY * (m_links[0].m_length - m_links[0].m_radius) * cos(m_links[0].m_theta))
		/ m_links[0].m_inertia;

	double alpha2 = (m_links[1].m_torque - m_links[2].m_torque + m_links[1].m_forceX * m_links[1].m_radius * sin(m_links[1].m_theta) - m_links[1].m_forceY * m_links[1].m_radius * cos(m_links[1].m_theta)
		+ m_links[2].m_forceX * (m_links[1].m_length - m_links[1].m_radius) * sin(m_links[1].m_theta) - m_links[2].m_forceY * (m_links[1].m_length - m_links[1].m_radius) * cos(m_links[1].m_theta))
		/ m_links[1].m_inertia;

	//For the final link, the end forces are zero.
	double alpha3 = (m_links[2].m_torque + m_links[2].m_forceX * m_links[2].m_radius * sin(m_links[2].m_theta) - m_links[2].m_forceY * m_links[2].m_radius * cos(m_links[2].m_theta))
		/ m_links[2].m_inertia;

	/*
	//Check alpha1 from the equation 1.
	double alpha1a = ((m_links[0].m_forceX - m_links[1].m_forceX) / (-m_links[0].m_mass * m_links[0].m_radius) - cos(m_links[0].f_ctw2())) / sin(m_links[0].m_theta);
	*/

	//Store and return the angular accelerations.
	Eigen::VectorXd temp(m_links.size());
	temp << alpha1, alpha2, alpha3;

	return temp;
}