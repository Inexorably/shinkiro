#include "linkage.h"

#define SHOW_DEBUG_OUTPUT true

/**********************************************************Base functions (constructor etc)************************************************/

//Default Link constructor, primarily useful for testing so we fill with some arbitrary values.
shinkiro::Link::Link() : m_length(2), m_radius(1), m_mass(1), m_intertia(1), m_theta(EIGEN_PI/4), m_omega(1), m_alpha(1), m_forceX(0), m_forceY(0), m_torque(0) {
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Link::Link(): Link constructed succesfully.\n";
	}
}

//Default Linkage constructor, primarily useful for testing so we fill with some arbitrary values.  Defaults to 3 link linkage.
shinkiro::Linkage::Linkage() {
	//We default to a 3 link linkage with the default link characteristics generated by the default constructor of Link.
	shinkiro::Link temp;

	//Fill the Link vector.
	for (int i = 0; i < 3; ++i) {
		m_links.push_back(temp);
	}
	if (SHOW_DEBUG_OUTPUT) {
		std::cout << "shinkiro::Linkage::Linkage(): Linkage constructed succesfully.\n";
	}
}

/**********************************************************Math helper functions***********************************************************/

//Returns cos(theta)*alpha.
double shinkiro::Link::f_cta() const {
	return cos(m_theta) * m_alpha;
}

//Returns sin(theta)*alpha.
double shinkiro::Link::f_sta() const {
	return sin(m_theta) * m_alpha;
}

//Returns cos(theta)*omega^2.
double shinkiro::Link::f_ctw2() const {
	return cos(m_theta) * pow(m_omega, 2);
}

//Returns sin(theta)*omega^2.
double shinkiro::Link::f_stw2() const {
	return sin(m_theta) * pow(m_omega, 2);
}

/**********************************************************Solver functions***************************************************************/

//Use inverse dynamics to calculate the forces and moments for a three link planar bipedal / inverted pendulum model.
//Assumes foot is massless and remains grounded for period of analysis.  Assumes that position, velocity, and acceleration values are known and defined in m_theta, m_omega, m_alpha.
//Returns a vector of the forces and torques of order [Fx1; Fx2; Fy1; Fy2; T1; T2; Fx3; Fy3; T3].
Eigen::VectorXd shinkiro::Linkage::f_inverseDynamics() {
	//Handle the cases for the current number of links.  Eventually generically handle linkages, but for now prototype around 3 link model.
	if (m_links.size() != 3) {
		std::cout << "Invalid linkage length\n";
		return Eigen::VectorXd(8);
	}

	//The inverse dynamics for linkage of length three can be written in the form Af=b.
	//Prellocate A and b.
	Eigen::MatrixXd A(8, 9);
	Eigen::VectorXd b(8);

	//Define the matrix A, which is 8x9.
	A << 1, -1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, -1, 0, 0, 0, 0, 0,
		1, -1, m_links[0].m_radius* sin(m_links[0].m_theta), -1 * m_links[0].m_radius * cos(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* sin(m_links[0].m_theta), (m_links[0].m_length - m_links[0].m_radius)* cos(m_links[0].m_theta), 0, 0, 0,
		0, 1, 0, 0, 0, 0, -1, 0, 0,
		0, 0, 0, 1, 0, 0, 0, -1, 0,
		0, m_links[1].m_radius* sin(m_links[1].m_theta), 0, -1 * m_links[1].m_radius * cos(m_links[1].m_theta), 0, 1, (m_links[1].m_length - m_links[1].m_radius)* sin(m_links[1].m_theta), -1 * (m_links[1].m_length - m_links[1].m_radius) * cos(m_links[1].m_theta), -1,
		0, 0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 1, 0;

	//Define the vector B, which is 8x1.
	b << -m_links[0].m_mass * m_links[0].m_radius * (m_links[0].f_sta() + m_links[0].f_ctw2()),
		m_links[0].m_mass* (m_links[0].m_radius * (m_links[0].f_cta() - m_links[0].f_stw2()) + shinkiro::g),
		m_links[0].m_intertia* m_links[0].m_alpha,
		-m_links[1].m_mass * (m_links[0].m_length * (m_links[0].f_sta() + m_links[0].f_ctw2()) + m_links[1].m_radius * (m_links[1].f_sta() + m_links[1].f_ctw2())),
		m_links[1].m_mass * (m_links[0].m_length * (m_links[0].f_cta() - m_links[0].f_stw2()) + m_links[1].m_radius * (m_links[1].f_cta() - m_links[1].f_stw2()) + shinkiro::g),
		m_links[1].m_intertia * m_links[1].m_alpha,
		-m_links[2].m_mass * (m_links[0].m_length * (m_links[0].f_sta() + m_links[0].f_ctw2()) + m_links[1].m_length * (m_links[1].f_sta() + m_links[1].f_ctw2()) + m_links[2].m_radius * (m_links[2].f_sta() + m_links[2].f_ctw2())),
		m_links[2].m_mass * (m_links[0].m_length * (m_links[0].f_cta() - m_links[0].f_stw2()) + m_links[1].m_length * (m_links[1].f_cta() - m_links[1].f_stw2()) + m_links[2].m_radius * (m_links[2].f_cta() - m_links[2].f_stw2()) + shinkiro::g);


	//Find f = b\A.
	return A.colPivHouseholderQr().solve(b);
}